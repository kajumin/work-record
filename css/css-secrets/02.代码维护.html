<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
  <style>
    .callout {
      width: 100px;
      height: 100px;
      background-color: red;
      position: relative;
    }

    .callout::before {
      content: "";
      position: absolute;
      top: -0.35em;
      left: 1em;
      padding: .35em;
      background: inherit;
      border: inherit;
      border-right: 0;
      border-bottom: 0;
      transform: rotate(45deg);
    }
  </style>
</head>

<body>
  <!-- 
    1. 代码易维护 vs. 代码量少 
      有时不可兼得  padding: 10px 10px 10px 0;并不好
    2.currentColor: hr元素与文本保持一致
    3.继承 inherit
    4.合理使用简写  background 和 background-color的区别  后者可能得到其他imge
      配合简写和展开式 多个background时 background-repeat/size可以单独出来写
  -->
  <!-- 
    1.使用百分比长度来取代固定长度。如果实在做不到这一点，也应该
    尝试使用与视口相关的单位（vw、vh、vmin 和 vmax），它们的值解
    析为视口宽度或高度的百分比。
    2.当你需要在较大分辨率下得到固定宽度时，使用 max-width 而不是
    width，因为它可以适应较小的分辨率，而无需使用媒体查询。
    3.不要忘记为替换元素（比如 img、object、video、iframe 等）设
    置一个 max-width，值为 100%。
    4.假如背景图片需要完整地铺满一个容器，不管容器的尺寸如何变化，
    background-size: cover 这个属性都可以做到。但是，我们也要时
    刻牢记——带宽并不是无限的，因此在移动网页中通过 CSS 把一张
    大图缩小显示往往是不太明智的。
    5.当图片（或其他元素）以行列式进行布局时，让视口的宽度来决定
    列的数量。弹性盒布局（即 Flexbox）或者 display: inline-block
    加上常规的文本折行行为，都可以实现这一点。 
  -->
  <div class="callout"></div>
</body>

</html>